# 第一章 程序设计基本概念
> 简单的程序设计一般包含以下几个部分:
* 确定数据结构
* 确定算法
* 编码
* 在计算机上调试程序
* 整理并写出文档资料

> 一个算法应当具有以下五个特性：
* 有穷性
* 确定性
* 可行性
* 有零个或多个输入
* 有零个或多个输出

> 结构化程序由3种基本结构组成
* 顺序结构
* 选择结构
* 循环结构

# 第二章 C程序设计的初步知识
> 标识符
* 合法标识符的命名规则是:标识符可以由字母,数字和下划线组成,并且第一个字符必须为字母或下划线.
1. 关键字
* C语言已经预先规定了一批标识符,它们在程序中都代表着固定的含义,不能另作他用,这些标识符称为关键字.例如,`int`,`double`
2. 预定义标识符
* C语言中预先定义并具有特定含义的标识符,如`printf`,`define`
3. 用户标识符
* 由用户根据需要定义的标识符称为用户标识符,又称自定义标识符.
> 强制类型转换
* (类型名)(表达式)
> 赋值运算符
* 变量名 = 表达式;

# 第三章 顺序结构
> 输出语句
```c
printf("a = %d,b = %d", a, b);
```

> 输入语句
```c
scanf("%d%f%lf", &x, &y, &z);
```

> 复合语句
* 几个语句用大括号括起来,一个复合语句在语法上视为一条语句

# 第四章 选择结构
> if...else...
```c
if (a > b)
    max = a;
else
    max = b;
```
* else子句总是与前面最近的不带else的if相结合
```c
if (a = 1)
    ...
else if (a = 2)
    ...
else if (a = 3)
    ...
```
> 条件表达式: 唯一一个三元运算符
* `表达式1?表达式2:表达式3`  
`表达式1`为非零时,求`表达式2`,`表达式1`为零时,求`表达式3`.

> switch语句
```c
switch (a)
{
    case 0: ...;
    case 1: ...;
    case 2: ...;
    default: ...;
}
```
* 找到case后下面的语句依然会被执行

> switch语句与break语句配合
```c
switch (a)
{
    case 0: ...;break;
    case 1: ...;break;
    case 2: ...;break;
    default: ...;
}
```
> 语句标号
* 语句标号不必定义,在标识符后面加冒号,就成了一个语句标号,通常标号用作`goto`语句的转向目标.`goto 语句标号;`

# 第五章 循环结构

> while循环
```c
while (i > 0)
{
    i--;
}

//do...while语句
do
{
    i--;
}
while (i > 0);
```

> for语句
```c
for(i=0;i<10;i++)
{
    printf("%d", i);
}
```
> break语句
* 跳出本层循环

> continue语句
* 结束本次循环,进行下一次的循环条件判定

# 第六章 字符型数据

> 字符常量
* 用单引号把一个字符括起来, `'a'`,`'!'`

> 转义字符常量
* `\n`,`\t`

> 字符串常量
* `"abc"`

> 字符变量
* 用`char`进行定义
```c
char ch1 = '*';
printf ("a=%c", a);
scanf("%c%c%c", &a, &b, &c);
putchar('Y');
ch1 = getchar();
```

# 第七章 函数

> 库函数
* 调用库函数应在源程序前加`#include<....h>`
* 对库函数一般调用形式为:`函数名(参数表)`

> 函数定义
* C语言函数定义的一般形式如下:
```
函数返回值的类型 函数名(类型名 形式参数1, 类型名 形式参数2, ...)
{
    说明部分
    语句部分
}
```

> 函数的调用
* `函数名(实参表)`

> 调用函数和被调用函数之间的数据传递
* 实参的值传递给对应的形参,但形参的变化不会影响对应的实参.

# 第八章 地址和指针

> 定义指针变量
* `类型名 *指针变量名1, *指针变量名2;`

> 给指针变量赋地址值
```c
int k = 1, *q, *p;
q = &k;
//&只能用于变量和数组
```

> 通过指针来引用一个存储单元
* 间接访问运算符`*`,运算对象为:指针变量或地址.
```c
int *p, i = 10, j;
p = &i;
j = *p;//相当于j = i
```

# 第九章 数组

> 一维数组的定义
* `类型名 数组名[整型常量表达式];` `int a[8];`

> 一维数组的引用
* `数组名[下标表达式]`

> 一维数组的初始化
* `int a[8] = {0,1,2,3,4,5,,6,7};`

> 二维数组的定义
* `类型名 数组名[常量表达式1][常量表达式2];`

> 二维数组的引用
* `数组名[下标表达式1][下标表达式2]`

> 二维数组的初始化
* `int a[4][3] = {{1,2,3},{4,5,6},{7,8,9}};`

# 第十章 字符串
* 字符串是借助一维数组存放的.

* C语言中字符串常亮给出的是地址值

> 给一维字符数组赋初值
```c
char str[10] = {'s','t','r','i','n','g','!','\0'};
char str[10] = {"string!"};
```

> 用%s进行整串输入输出
```c
char str[15];
scanf("%s",str);  //若输入空格,后面的字符串将丢失
gets(str);        //空格将保留
```

> 用于字符串处理的函数
* `#include<string.h>`
* 字符串复制函数,`strcpy(s1,s2)`,将s2复制到s1.
* 字符串连接函数,`strcat(s1,s2)`,将s2连接到s1后面.
* 求字符串长度函数,`strlen(s)`,计算字符串长度.
* 字符串比较函数,`strcmp(s1,s2),比较s1和s2所指字符串的大小.

# 第十一章 对函数的进一步讨论
> 函数的递归调用
* 直接或间接地调用自己

# 第十二章 C语言中用户标识符的作用域和存储类
* 局部变量:在函数内部或复合语句内部定义的变量
* 全局变量:在函数外部定义的变量

> 在C语言中,有两种存储类别:一种是自动类,一种是静态类.局部变量既可以说明成自动类,也可以说明成静态类;而全局变量只能是静态类.
* 说明符: auto(自动),register(寄存器),static(静态),extern(外部)
* auto变量的存储单元被分配在内存的动态存储区,每当进入函数体时,系统自动为auto变量分配存储单元;退出时自动释放这些存储单元另作他用.
* register变量是自动类变量,但值保留在寄存器中,二不占内存单元,速度更快.
* static局部变量域自动作用域相同:但生存期直到程序运行结束,初值在编译时赋予.
* 全局变量作用域:从变量定义的位置开始,到整个源文件结束.生存期:整个程序运行期间.
* extern:当全局变量定义在后,引用它的函数在前时,应该在引用它的函数中用extern对此全局变量进行说明,以便通知该程序;该变量是一个已知在外部定义了的全局变量,已经分配了存储单元,不需再为它另外开辟存储单元.

> 用extern说明函数
* 在函数返回值类型前加上说明符extern或省略则是外部函数,可以被其他编译单位中的函数调用.

> 用static说明函数
* 在函数返回值类型前加上static,则是内部函数,只限本编译单位中的函数调用.

# 第十三章 编译的预处理和动态内存分配
* 在C语言中,凡是以"#"号开头的行,都称为"编译预处理"命令行.

> 宏替换(不带参数的宏替换)
* #define 宏名 替换文本
* #define SIZE 100
* 替换文本中可以包含已定义过的宏名
* 当定义在一行中写不下,需要在下一行继续时,只需在最后一个字符后紧接着加一个反斜线"\".
* 同一个宏名不能重复定义,除非两个宏定义命令完全一致.
* 替换文本不能替换双引号中与宏名完全相同的字符串.
* 替换文本并不替换用户标识符中的成分.
* 用作红名的标识符通常用大写字母表示.
* 在C语言中,宏定义位置一般在程序开头.

> 带参数的宏定义
* #define 宏名(形参表) 替换文本
* #define MU(X,Y) ((X)*(Y))

> 终止宏定义
* 用`#undef`提前终止宏定义的作用域
```c
#define PI 3.14
...
#undef PI
```

> 文件包含
* `#include<stdio.h>`

> 动态存储分配
* C标准为动态分配定义了四个函数,`malloc`,`calloc`,`free`和`realloc`,使用这些函数时,必须包含头文件`stdlib.h`
```c
int* p = malloc(sizeof(int)*n);
free(p);
```

# 第十四章 结构体.共同体和用户定义类型
> 用`typedef`说明一种新类型名
* typedef 类型名 标识符;
* typedef语句的作用仅仅是用"标识符"来代表已存在的"类型名",并来产生新的数据类型,原有类型名依然有效.

> 结构体
* 结构体类型说明
